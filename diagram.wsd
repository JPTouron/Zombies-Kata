@startuml "Zombies Class diagram"

title "Zombies Class diagram"

package Domain{

    frame Gear{

        interface IEquipment{
            +string Name { get; }
        }

        abstract class EquipmentBase
        {
            +string Name {get;}
        }
        IEquipment <|--EquipmentBase

        class NoEquipment
        {
            +string Name {get;}
        }

        note right
            ""Name => string.empty""
        end note

        EquipmentBase <|-right- NoEquipment


        class Equipment
        {
            +ctor(string Name)
            __
            +string Name {get;}
        }

        EquipmentBase <|-- Equipment
    }

    frame Inventory{

        interface IInventoryHandler
        {
            +IReadOnlyCollection<IEquipment> Items { get; }
            +void AddEquipment(IEquipment equipment)
            +bool ContainsEquipment(IEquipment equipment)
            +void ReduceCapacityBy(int reduction)
        }

        class InventoryProvider{
            +IInventoryHandler GetInventory()
        }
        note left
            //factory class//
        end note
        IInventoryHandler o-left- InventoryProvider

        class InventoryHandler
        {
            -int capacity
            -IList<Equipment> items;
            ..
            +ctor()
            __
            +IReadOnlyCollection<Equipment> Items {get;}
            ..
            +void AddEquipment(Equipment equipment)
            +void ReduceCapacityBy(int reduction)
            +bool ContainsEquipment(Equipment equipment)
        }

        note right
            manages all the equipment
            a Survivor may carry
            In Hand or In Reserve

            ""ReduceCapacityBy(...)""
            //would loose a random equipment//
        end note

        IInventoryHandler <|- InventoryHandler
        Equipment *-- InventoryHandler
    }

    frame Health {

        enum State{
            +Alive
            +Dead
        }

        interface IHealth
        {
            +State CurrentState  { get; }
            +int Wounds { get;}
            +Wound(int inflictedWounds)
        }

        class Health
        {
            +ctor()
            __
            +State CurrentState { get; private set; }
            +int Wounds { get; private set;}
            +Wound(int inflictedWounds)
        }

        note right
            "" Wound() ""
            "" if inflictedWounds < 2 => Dead""
        end note

        State *-up- Health
        IHealth <|- Health
    }

    frame XP {
        enum XpLevel
        {
            +Blue
            +Yellow
            +Orange
            +Red
        }



        class Experience
        {
            +ctor()
            __
            +XpLevel Level {get}
            +int Value {get}
            +int MaxValue {get}
            +int Increase()
        }
        note left
            <b>Value starts at zero</b>

            * When a Survivor exceeds 6 Experience, they advance to level //Yellow//
            * When a Survivor exceeds 18 Experience, they advance to level //Orange//
            * When a Survivor exceeds 42 Experience, they advance to level //Red//

            Value holds the current xp value
            MaxValue  holds the value when we level up in the current level (6,18, 42, etc...)

            ""Increase()""
            //only increases by one//
        end note

        XpLevel *-down- Experience
        IExperience <|-left- Experience
    }

    interface IExperience{
        +int Experience {get}
        +XpLevel XpLevel {get}
    }

    class Survivor
    {
        -InventoryHandler InventoryHandler
        -const int capacityReductionPerWound = 1
        -IEquipment rightHandEquip
        -IEquipment leftHandEquip
        ..
        +ctor(string name)
        __
        +string Name {get;}
        +int RemainingActions  { get; }
        --
        +State CurrentState  { get; }
        +int Wounds { get; }
        ..
        +void Wound(int inflictedWounds)
        +void AddEquipment(IEquipment equipment);
        ..
        +IEquipment RightHandEquip {get;set;}
        +IEquipment LeftHandEquip {get;set;}
        +IReadOnlyCollection<IEquipment> Items {get;}
        ..
        +int Experience {get}
        +XpLevel XpLevel {get}
        ..
        +void Kill(Zombie zombie)
    }

    note left
        // Survivor would be initialized with: zero wounds, //
        // three remaining actions, Alive CurrentState //

        "" AddEquipment(..) ""
        // InventoryHandler.Add...//

        ""Items""
        // All available items //
    end note

    Health +-up- Survivor
    IHealth <|- Survivor
    Experience +-- Survivor
    IExperience <|-- Survivor
    InventoryHandler +-- Survivor


    class Zombie {

    }
    note right
        placeholder, we don't have info on this
    end note


    abstract class Skill{
        #XpLevel UnlocksAt {get;}
    }

    class SkillComposite{
        +IList<Skill> Skills {get;}
    }

    Skill <|-- SkillComposite
    SkillComposite *-- Skill

    class YellowSkillLeaf{
        //UnlocksAt => Yellow
        +Skill skill{get;} => +1 Action

    }

    Skill <|- YellowSkillLeaf
    class OrangeSkillLeaf{
        //UnlocksAt => Orange
        +Skill skill{get;}
        +Skill skill{get;}

    }
    Skill <|-- OrangeSkillLeaf

    class RedSkillLeaf{
        //UnlocksAt => red
        +Skill skill{get;}
        +Skill skill{get;}
        +Skill skill{get;}
    }
    Skill <|-- RedSkillLeaf

    class SkillTree{

        -SkillComposite potentialSkills

    }
    note left 
    IT MAY BE COOL TO IMPLEMENT A NORMAL Skill
    AS THESE SKILLS SHOULD CHANGE THE SURVIVOR BEHAVIOR
    THEN THESE ARE STRATEGIES, A NORMAL SKILL CAN APPLY TO ANYTHING
    SO WE SHOULD HAVE A NORMAL HEALTH, NORMAL ATTACK OR NORMAL WHATEV
    THEN THESE NORMAL CRAP SHOULD COMPRISE THE ROOT OF OUR SkillTree
    BEING STRATEGIES WE'D NEED A PROVIDER FOR THESE, AND THAT PROVIDER 
    SHOULD BE THE SKILL LEAFS (RedSkillLeaf, YellowSkillLeaf, ETC)
    THEN WE'D HAVE TO FIND A WAY THROUGH THE SkillTree TO INVOKE 
    THE PROPER SKILL STRATEGY 
    (maybe a visitor is in order... should check, maybe just a strategy is ok)
    end note

    SkillComposite <-- SkillTree
    SkillTree *-- Survivor

}

package Application{
    enum GameState{
        +OnGoing
        +Finished
    }
    class Game
    {
        -IList<Survivor> survivors
        ....
        +GameState State
        +int SurvivorCount
        +void AddSurvivor(Survivor survivor)
        --
        +int Experience {get}
        +XpLevel Level {get}
    }

    note left
        ""Experience""
        // would have to perform a calculation to get the ""Experience.Value"" from the most leveled up survivor //

        ""XpLevel""
        // same calculation as for ""Experience"" //
    end note

    Survivor <-- Game
    GameState *-up- Game
    IExperience <|-- Game

}


@enduml